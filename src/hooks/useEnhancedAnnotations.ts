/**
 * Enhanced Annotations Management Hook
 *
 * Provides comprehensive annotation management including:
 * - Professional dimension systems
 * - Text annotations with leader lines
 * - Area calculations and annotations
 * - Material callouts and specifications
 * - Automatic annotation generation
 * - Export-ready annotation formatting
 */

import { useState, useCallback } from 'react';
import {
  TextAnnotation,
  AreaAnnotation,
  MaterialCallout,
  AnnotationTextStyle,
  AreaAnnotationStyle,
  CalloutStyle
} from '@/components/Annotations/EnhancedAnnotationRenderer2D';
import {
  useDimensionManager2D,
  UseDimensionManagerOptions
} from './useDimensionManager2D';
import { Point2D, Element2D, Room2D } from '@/types/elements2D';
import { ViewType2D } from '@/types/views';
import { Material } from '@/types/materials/Material';
import { Dimension2D, DimensionChain2D, DimensionType } from '@/utils/dimensionManager2D';

export interface UseEnhancedAnnotationsOptions {
  viewType: ViewType2D;
  floorId: string;
  autoGenerate?: boolean;
  dimensionOptions?: UseDimensionManagerOptions;
}

export interface UseEnhancedAnnotationsReturn {
  // Dimension management (from existing hook)
  dimensions: Dimension2D[];
  chains: DimensionChain2D[];
  createDimension: (startPoint: Point2D, endPoint: Point2D, type?: DimensionType, options?: Partial<Dimension2D>) => Dimension2D;
  updateDimension: (id: string, updates: Partial<Dimension2D>) => boolean;
  deleteDimension: (id: string) => boolean;
  autoGenerateDimensions: (elements: Element2D[]) => Dimension2D[];
  clearAutoDimensions: () => void;

  // Text annotations
  textAnnotations: TextAnnotation[];
  createTextAnnotation: (position: Point2D, text: string, options?: Partial<TextAnnotation>) => TextAnnotation;
  updateTextAnnotation: (id: string, updates: Partial<TextAnnotation>) => boolean;
  deleteTextAnnotation: (id: string) => boolean;

  // Area annotations
  areaAnnotations: AreaAnnotation[];
  createAreaAnnotation: (points: Point2D[], label: string, options?: Partial<AreaAnnotation>) => AreaAnnotation;
  updateAreaAnnotation: (id: string, updates: Partial<AreaAnnotation>) => boolean;
  deleteAreaAnnotation: (id: string) => boolean;
  calculateRoomAreas: (rooms: Room2D[]) => AreaAnnotation[];

  // Material callouts
  materialCallouts: MaterialCallout[];
  createMaterialCallout: (position: Point2D, material: Material, options?: Partial<MaterialCallout>) => MaterialCallout;
  updateMaterialCallout: (id: string, updates: Partial<MaterialCallout>) => boolean;
  deleteMaterialCallout: (id: string) => boolean;
  autoGenerateMaterialCallouts: (elements: Element2D[], materials: Material[]) => MaterialCallout[];

  // Bulk operations
  clearAllAnnotations: () => void;
  exportAnnotations: () => unknown;
  importAnnotations: (data: unknown) => void;

  // Selection and editing
  selectedAnnotationId: string | null;
  selectedAnnotationType: 'dimension' | 'text' | 'area' | 'material' | null;
  selectAnnotation: (id: string, type: 'dimension' | 'text' | 'area' | 'material') => void;
  clearSelection: () => void;

  // Visibility and filtering
  toggleAnnotationVisibility: (id: string, type: string) => void;
  toggleCategoryVisibility: (category: string) => void;
  filterAnnotationsByCategory: (category: string) => void;

  // Styles and templates
  defaultTextStyle: AnnotationTextStyle;
  defaultAreaStyle: AreaAnnotationStyle;
  defaultCalloutStyle: CalloutStyle;
  updateDefaultStyles: (styles: unknown) => void;
}

// Default styles
const DEFAULT_TEXT_STYLE: AnnotationTextStyle = {
  fontSize: 12,
  fontFamily: 'Arial',
  fontWeight: 'normal',
  color: '#333333',
  backgroundColor: '#ffffff',
  borderColor: '#cccccc',
  borderWidth: 1,
  padding: 4,
  alignment: 'left',
  rotation: 0
};

const DEFAULT_AREA_STYLE: AreaAnnotationStyle = {
  fillColor: 'rgba(0, 123, 255, 0.1)',
  fillOpacity: 0.2,
  strokeColor: '#007bff',
  strokeWidth: 2,
  strokeDashArray: [5, 5],
  labelStyle: DEFAULT_TEXT_STYLE
};

const DEFAULT_CALLOUT_STYLE: CalloutStyle = {
  bubbleColor: '#ffffff',
  textColor: '#333333',
  borderColor: '#007bff',
  borderWidth: 2,
  fontSize: 11,
  leaderStyle: 'straight'
};

export function useEnhancedAnnotations(options: UseEnhancedAnnotationsOptions): UseEnhancedAnnotationsReturn {
  const { viewType, floorId, autoGenerate = true, dimensionOptions = {} } = options;

  // Use existing dimension manager
  const dimensionManager = useDimensionManager2D({
    autoGenerate,
    enabled: true,
    viewType,
    floorId,
    ...dimensionOptions
  });

  // State for different annotation types
  const [textAnnotations, setTextAnnotations] = useState<TextAnnotation[]>([]);
  const [areaAnnotations, setAreaAnnotations] = useState<AreaAnnotation[]>([]);
  const [materialCallouts, setMaterialCallouts] = useState<MaterialCallout[]>([]);

  // Selection state
  const [selectedAnnotationId, setSelectedAnnotationId] = useState<string | null>(null);
  const [selectedAnnotationType, setSelectedAnnotationType] = useState<'dimension' | 'text' | 'area' | 'material' | null>(null);

  // Style state
  const [defaultTextStyle, setDefaultTextStyle] = useState<AnnotationTextStyle>(DEFAULT_TEXT_STYLE);
  const [defaultAreaStyle, setDefaultAreaStyle] = useState<AreaAnnotationStyle>(DEFAULT_AREA_STYLE);
  const [defaultCalloutStyle, setDefaultCalloutStyle] = useState<CalloutStyle>(DEFAULT_CALLOUT_STYLE);

  // Text annotation functions
  const createTextAnnotation = useCallback((
    position: Point2D,
    text: string,
    options: Partial<TextAnnotation> = {}
  ): TextAnnotation => {
    const annotation: TextAnnotation = {
      id: `text-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      position,
      text,
      style: { ...defaultTextStyle, ...options.style },
      hasLeader: options.hasLeader || false,
      leaderPoints: options.leaderPoints,
      category: options.category || 'note',
      isVisible: options.isVisible !== false,
      layer: options.layer || 0,
      ...options
    };

    setTextAnnotations(prev => [...prev, annotation]);
    return annotation;
  }, [defaultTextStyle]);

  const updateTextAnnotation = useCallback((id: string, updates: Partial<TextAnnotation>): boolean => {
    setTextAnnotations(prev => {
      const index = prev.findIndex(ann => ann.id === id);
      if (index === -1) return prev;

      const updated = [...prev];
      updated[index] = { ...updated[index], ...updates };
      return updated;
    });
    return true;
  }, []);

  const deleteTextAnnotation = useCallback((id: string): boolean => {
    setTextAnnotations(prev => prev.filter(ann => ann.id !== id));
    if (selectedAnnotationId === id) {
      setSelectedAnnotationId(null);
      setSelectedAnnotationType(null);
    }
    return true;
  }, [selectedAnnotationId]);

  // Area annotation functions
  const calculateArea = useCallback((points: Point2D[]): number => {
    if (points.length < 3) return 0;

    let area = 0;
    for (let i = 0; i < points.length; i++) {
      const j = (i + 1) % points.length;
      area += points[i].x * points[j].y;
      area -= points[j].x * points[i].y;
    }
    return Math.abs(area) / 2;
  }, []);

  const calculatePerimeter = useCallback((points: Point2D[]): number => {
    if (points.length < 2) return 0;

    let perimeter = 0;
    for (let i = 0; i < points.length; i++) {
      const j = (i + 1) % points.length;
      const dx = points[j].x - points[i].x;
      const dy = points[j].y - points[i].y;
      perimeter += Math.sqrt(dx * dx + dy * dy);
    }
    return perimeter;
  }, []);

  const createAreaAnnotation = useCallback((
    points: Point2D[],
    label: string,
    options: Partial<AreaAnnotation> = {}
  ): AreaAnnotation => {
    const area = calculateArea(points);
    const perimeter = calculatePerimeter(points);

    const annotation: AreaAnnotation = {
      id: `area-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      points,
      area,
      perimeter,
      label,
      unit: options.unit || 'm',
      style: { ...defaultAreaStyle, ...options.style },
      showCalculations: options.showCalculations !== false,
      isVisible: options.isVisible !== false,
      ...options
    };

    setAreaAnnotations(prev => [...prev, annotation]);
    return annotation;
  }, [calculateArea, calculatePerimeter, defaultAreaStyle]);

  const updateAreaAnnotation = useCallback((id: string, updates: Partial<AreaAnnotation>): boolean => {
    setAreaAnnotations(prev => {
      const index = prev.findIndex(ann => ann.id === id);
      if (index === -1) return prev;

      const updated = [...prev];
      const annotation = { ...updated[index], ...updates };

      // Recalculate area and perimeter if points changed
      if (updates.points) {
        annotation.area = calculateArea(updates.points);
        annotation.perimeter = calculatePerimeter(updates.points);
      }

      updated[index] = annotation;
      return updated;
    });
    return true;
  }, [calculateArea, calculatePerimeter]);

  const deleteAreaAnnotation = useCallback((id: string): boolean => {
    setAreaAnnotations(prev => prev.filter(ann => ann.id !== id));
    if (selectedAnnotationId === id) {
      setSelectedAnnotationId(null);
      setSelectedAnnotationType(null);
    }
    return true;
  }, [selectedAnnotationId]);

  const calculateRoomAreas = useCallback((rooms: Room2D[]): AreaAnnotation[] => {
    return rooms.map(room => {
      const points = room.points || [];
      if (points.length < 3) return null;

      return createAreaAnnotation(
        points,
        room.name || 'Room',
        {
          unit: 'm',
          showCalculations: true,
          style: {
            ...defaultAreaStyle,
            fillColor: 'rgba(40, 167, 69, 0.1)',
            strokeColor: '#28a745'
          }
        }
      );
    }).filter(Boolean) as AreaAnnotation[];
  }, [createAreaAnnotation, defaultAreaStyle]);

  // Material callout functions
  const createMaterialCallout = useCallback((
    position: Point2D,
    material: Material,
    options: Partial<MaterialCallout> = {}
  ): MaterialCallout => {
    const callout: MaterialCallout = {
      id: `material-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      position,
      materialId: material.id,
      materialName: material.name,
      specifications: [
        material.metadata.description,
        `Category: ${material.category}`,
        material.metadata.manufacturer ? `Manufacturer: ${material.metadata.manufacturer}` : '',
        material.metadata.productCode ? `Product Code: ${material.metadata.productCode}` : ''
      ].filter(Boolean),
      quantity: options.quantity,
      unit: options.unit,
      style: { ...defaultCalloutStyle, ...options.style },
      isVisible: options.isVisible !== false,
      ...options
    };

    setMaterialCallouts(prev => [...prev, callout]);
    return callout;
  }, [defaultCalloutStyle]);

  const updateMaterialCallout = useCallback((id: string, updates: Partial<MaterialCallout>): boolean => {
    setMaterialCallouts(prev => {
      const index = prev.findIndex(callout => callout.id === id);
      if (index === -1) return prev;

      const updated = [...prev];
      updated[index] = { ...updated[index], ...updates };
      return updated;
    });
    return true;
  }, []);

  const deleteMaterialCallout = useCallback((id: string): boolean => {
    setMaterialCallouts(prev => prev.filter(callout => callout.id !== id));
    if (selectedAnnotationId === id) {
      setSelectedAnnotationId(null);
      setSelectedAnnotationType(null);
    }
    return true;
  }, [selectedAnnotationId]);

  const autoGenerateMaterialCallouts = useCallback((elements: Element2D[], materials: Material[]): MaterialCallout[] => {
    const callouts: MaterialCallout[] = [];

    elements.forEach(element => {
      if (element.materialId) {
        const material = materials.find(m => m.id === element.materialId);
        if (material) {
          const position = element.transform.position || { x: 0, y: 0 };
          const callout = createMaterialCallout(
            { x: position.x + 1, y: position.y - 1 }, // Offset slightly
            material,
            {
              quantity: 1,
              unit: element.type === 'wall' ? 'm' : 'ea'
            }
          );
          callouts.push(callout);
        }
      }
    });

    return callouts;
  }, [createMaterialCallout]);

  // Selection functions
  const selectAnnotation = useCallback((id: string, type: 'dimension' | 'text' | 'area' | 'material') => {
    setSelectedAnnotationId(id);
    setSelectedAnnotationType(type);
  }, []);

  const clearSelection = useCallback(() => {
    setSelectedAnnotationId(null);
    setSelectedAnnotationType(null);
  }, []);

  // Visibility functions
  const toggleAnnotationVisibility = useCallback((id: string, type: string) => {
    switch (type) {
      case 'text':
        updateTextAnnotation(id, { isVisible: !textAnnotations.find(a => a.id === id)?.isVisible });
        break;
      case 'area':
        updateAreaAnnotation(id, { isVisible: !areaAnnotations.find(a => a.id === id)?.isVisible });
        break;
      case 'material':
        updateMaterialCallout(id, { isVisible: !materialCallouts.find(a => a.id === id)?.isVisible });
        break;
    }
  }, [textAnnotations, areaAnnotations, materialCallouts, updateTextAnnotation, updateAreaAnnotation, updateMaterialCallout]);

  const toggleCategoryVisibility = useCallback((category: string) => {
    setTextAnnotations(prev =>
      prev.map(ann =>
        ann.category === category
          ? { ...ann, isVisible: !ann.isVisible }
          : ann
      )
    );
  }, []);

  // Bulk operations
  const clearAllAnnotations = useCallback(() => {
    setTextAnnotations([]);
    setAreaAnnotations([]);
    setMaterialCallouts([]);
    dimensionManager.clearAutoDimensions();
    clearSelection();
  }, [dimensionManager, clearSelection]);

  const exportAnnotations = useCallback(() => {
    return {
      dimensions: dimensionManager.dimensions,
      chains: dimensionManager.chains,
      textAnnotations,
      areaAnnotations,
      materialCallouts,
      styles: {
        defaultTextStyle,
        defaultAreaStyle,
        defaultCalloutStyle
      }
    };
  }, [dimensionManager, textAnnotations, areaAnnotations, materialCallouts, defaultTextStyle, defaultAreaStyle, defaultCalloutStyle]);

  const importAnnotations = useCallback((data: unknown) => {
    if (typeof data === 'object' && data !== null) {
      const annotationData = data as any;
      if (annotationData.textAnnotations) setTextAnnotations(annotationData.textAnnotations);
      if (annotationData.areaAnnotations) setAreaAnnotations(annotationData.areaAnnotations);
      if (annotationData.materialCallouts) setMaterialCallouts(annotationData.materialCallouts);
      if (annotationData.styles) {
        if (annotationData.styles.defaultTextStyle) setDefaultTextStyle(annotationData.styles.defaultTextStyle);
        if (annotationData.styles.defaultAreaStyle) setDefaultAreaStyle(annotationData.styles.defaultAreaStyle);
        if (annotationData.styles.defaultCalloutStyle) setDefaultCalloutStyle(annotationData.styles.defaultCalloutStyle);
      }
    }
  }, []);

  const updateDefaultStyles = useCallback((styles: unknown) => {
    if (typeof styles === 'object' && styles !== null) {
      const styleData = styles as any;
      if (styleData.textStyle) setDefaultTextStyle(prev => ({ ...prev, ...styleData.textStyle }));
      if (styleData.areaStyle) setDefaultAreaStyle(prev => ({ ...prev, ...styleData.areaStyle }));
      if (styleData.calloutStyle) setDefaultCalloutStyle(prev => ({ ...prev, ...styleData.calloutStyle }));
    }
  }, []);

  const filterAnnotationsByCategory = useCallback((_category: string) => {
    // Implementation for filtering - could be used for display purposes
  }, []);

  return {
    // Dimension management (delegated to existing hook)
    dimensions: dimensionManager.dimensions,
    chains: dimensionManager.chains,
    createDimension: dimensionManager.createDimension,
    updateDimension: dimensionManager.updateDimension,
    deleteDimension: dimensionManager.deleteDimension,
    autoGenerateDimensions: dimensionManager.autoGenerateDimensions,
    clearAutoDimensions: dimensionManager.clearAutoDimensions,

    // Text annotations
    textAnnotations,
    createTextAnnotation,
    updateTextAnnotation,
    deleteTextAnnotation,

    // Area annotations
    areaAnnotations,
    createAreaAnnotation,
    updateAreaAnnotation,
    deleteAreaAnnotation,
    calculateRoomAreas,

    // Material callouts
    materialCallouts,
    createMaterialCallout,
    updateMaterialCallout,
    deleteMaterialCallout,
    autoGenerateMaterialCallouts,

    // Bulk operations
    clearAllAnnotations,
    exportAnnotations,
    importAnnotations,

    // Selection and editing
    selectedAnnotationId,
    selectedAnnotationType,
    selectAnnotation,
    clearSelection,

    // Visibility and filtering
    toggleAnnotationVisibility,
    toggleCategoryVisibility,
    filterAnnotationsByCategory,

    // Styles and templates
    defaultTextStyle,
    defaultAreaStyle,
    defaultCalloutStyle,
    updateDefaultStyles
  };
}

export default useEnhancedAnnotations;

/**
 * Dimension Manager for 2D Views
 * 
 * This system manages dimension annotations, measurements, and interactive
 * dimension editing across all 2D views (plan, front, back, left, right).
 * It provides automatic dimension detection, manual dimension creation,
 * and real-time dimension updates.
 */

import { Point2D, Element2D, Wall2D, Door2D, Window2D } from '@/types/elements2D';
import { ViewType2D } from '@/types/views';

// Dimension types
export type DimensionType = 
  | 'linear'      // Straight line distance
  | 'angular'     // Angle measurement
  | 'radial'      // Radius measurement
  | 'diameter'    // Diameter measurement
  | 'area'        // Area measurement
  | 'elevation'   // Height/elevation
  | 'continuous'; // Chain of connected dimensions

export type DimensionStyle = 
  | 'architectural' // Standard architectural dimensions
  | 'engineering'   // Engineering style
  | 'metric'        // Metric units
  | 'imperial';     // Imperial units

export interface DimensionPoint2D {
  id: string;
  position: Point2D;
  elementId?: string;  // Reference to element if snapped
  elementType?: string;
  snapType?: 'endpoint' | 'midpoint' | 'center' | 'intersection' | 'perpendicular';
}

export interface Dimension2D {
  id: string;
  type: DimensionType;
  startPoint: DimensionPoint2D;
  endPoint: DimensionPoint2D;
  value: number;
  unit: 'mm' | 'cm' | 'm' | 'in' | 'ft';
  label?: string;
  style: DimensionStyle;
  viewType: ViewType2D;
  floorId: string;
  
  // Visual properties
  offset: number;        // Distance from measured elements
  textSize: number;      // Text size
  arrowSize: number;     // Arrow head size
  lineWeight: number;    // Line thickness
  color: string;         // Dimension color
  
  // Behavior properties
  isAutomatic: boolean;  // Auto-generated vs manual
  isLocked: boolean;     // Prevent editing
  isVisible: boolean;    // Show/hide
  precision: number;     // Decimal places
  
  // Metadata
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
}

export interface DimensionChain2D {
  id: string;
  dimensions: Dimension2D[];
  totalValue: number;
  direction: 'horizontal' | 'vertical' | 'angled';
  baselineOffset: number;
  isLocked: boolean;
}

export interface DimensionManagerConfig {
  autoGenerate: boolean;
  defaultStyle: DimensionStyle;
  defaultUnit: 'mm' | 'cm' | 'm' | 'in' | 'ft';
  defaultOffset: number;
  defaultTextSize: number;
  defaultArrowSize: number;
  defaultLineWeight: number;
  defaultColor: string;
  snapTolerance: number;
  showTolerances: boolean;
  precision: number;
}

/**
 * Dimension Manager System
 * Handles creation, editing, and management of dimension annotations
 */
export class DimensionManager2D {
  private dimensions: Map<string, Dimension2D> = new Map();
  private chains: Map<string, DimensionChain2D> = new Map();
  private config: DimensionManagerConfig;

  private static defaultConfig: DimensionManagerConfig = {
    autoGenerate: true,
    defaultStyle: 'architectural',
    defaultUnit: 'm',
    defaultOffset: 0.5,
    defaultTextSize: 12,
    defaultArrowSize: 0.1,
    defaultLineWeight: 1,
    defaultColor: '#000000',
    snapTolerance: 0.05,
    showTolerances: false,
    precision: 2
  };

  constructor(config: Partial<DimensionManagerConfig> = {}) {
    this.config = { ...DimensionManager2D.defaultConfig, ...config };
  }

  /**
   * Create a new dimension
   */
  createDimension(
    startPoint: Point2D,
    endPoint: Point2D,
    type: DimensionType = 'linear',
    viewType: ViewType2D = 'plan',
    floorId: string = 'floor-1',
    options: Partial<Dimension2D> = {}
  ): Dimension2D {
    const id = `dim-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const startDimPoint: DimensionPoint2D = {
      id: `${id}-start`,
      position: startPoint
    };
    
    const endDimPoint: DimensionPoint2D = {
      id: `${id}-end`,
      position: endPoint
    };

    const value = this.calculateDistance(startPoint, endPoint);
    
    const dimension: Dimension2D = {
      id,
      type,
      startPoint: startDimPoint,
      endPoint: endDimPoint,
      value,
      unit: this.config.defaultUnit,
      style: this.config.defaultStyle,
      viewType,
      floorId,
      offset: this.config.defaultOffset,
      textSize: this.config.defaultTextSize,
      arrowSize: this.config.defaultArrowSize,
      lineWeight: this.config.defaultLineWeight,
      color: this.config.defaultColor,
      isAutomatic: false,
      isLocked: false,
      isVisible: true,
      precision: this.config.precision,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...options
    };

    this.dimensions.set(id, dimension);
    return dimension;
  }

  /**
   * Auto-generate dimensions for elements
   */
  autoGenerateDimensions(
    elements: Element2D[],
    viewType: ViewType2D = 'plan',
    floorId: string = 'floor-1'
  ): Dimension2D[] {
    if (!this.config.autoGenerate) return [];

    const generatedDimensions: Dimension2D[] = [];

    // Generate dimensions for walls
    const walls = elements.filter(el => el.type === 'wall2d') as Wall2D[];
    walls.forEach(wall => {
      const wallDimensions = this.generateWallDimensions(wall, viewType, floorId);
      generatedDimensions.push(...wallDimensions);
    });

    // Generate dimensions for rooms (if in plan view)
    if (viewType === 'plan') {
      const roomDimensions = this.generateRoomDimensions(elements, viewType, floorId);
      generatedDimensions.push(...roomDimensions);
    }

    // Generate elevation dimensions (if in elevation view)
    if (viewType !== 'plan') {
      const elevationDimensions = this.generateElevationDimensions(elements, viewType, floorId);
      generatedDimensions.push(...elevationDimensions);
    }

    return generatedDimensions;
  }

  /**
   * Generate dimensions for a wall
   */
  private generateWallDimensions(
    wall: Wall2D,
    viewType: ViewType2D,
    floorId: string
  ): Dimension2D[] {
    const dimensions: Dimension2D[] = [];

    // Wall length dimension
    const lengthDim = this.createDimension(
      wall.startPoint,
      wall.endPoint,
      'linear',
      viewType,
      floorId,
      {
        label: `Wall ${wall.id} Length`,
        isAutomatic: true,
        offset: this.config.defaultOffset
      }
    );
    dimensions.push(lengthDim);

    // Wall height dimension (for elevation views)
    if (viewType !== 'plan') {
      const heightDim = this.createDimension(
        wall.startPoint,
        { x: wall.startPoint.x, y: wall.startPoint.y + wall.height },
        'elevation',
        viewType,
        floorId,
        {
          label: `Wall ${wall.id} Height`,
          isAutomatic: true,
          offset: this.config.defaultOffset * 2
        }
      );
      dimensions.push(heightDim);
    }

    return dimensions;
  }

  /**
   * Generate room dimensions
   */
  private generateRoomDimensions(
    elements: Element2D[],
    viewType: ViewType2D,
    floorId: string
  ): Dimension2D[] {
    const dimensions: Dimension2D[] = [];
    
    // Find rectangular rooms and add overall dimensions
    const walls = elements.filter(el => el.type === 'wall2d') as Wall2D[];
    const rooms = this.detectRectangularRooms(walls);
    
    rooms.forEach((room, index) => {
      // Room width
      const widthDim = this.createDimension(
        room.bounds.min,
        { x: room.bounds.max.x, y: room.bounds.min.y },
        'linear',
        viewType,
        floorId,
        {
          label: `Room ${index + 1} Width`,
          isAutomatic: true,
          offset: this.config.defaultOffset * 3
        }
      );
      dimensions.push(widthDim);

      // Room height
      const heightDim = this.createDimension(
        room.bounds.min,
        { x: room.bounds.min.x, y: room.bounds.max.y },
        'linear',
        viewType,
        floorId,
        {
          label: `Room ${index + 1} Height`,
          isAutomatic: true,
          offset: this.config.defaultOffset * 3
        }
      );
      dimensions.push(heightDim);
    });

    return dimensions;
  }

  /**
   * Generate elevation-specific dimensions
   */
  private generateElevationDimensions(
    elements: Element2D[],
    viewType: ViewType2D,
    floorId: string
  ): Dimension2D[] {
    const dimensions: Dimension2D[] = [];

    // Door and window heights
    const doors = elements.filter(el => el.type === 'door2d') as Door2D[];
    const windows = elements.filter(el => el.type === 'window2d') as Window2D[];

    doors.forEach(door => {
      const heightDim = this.createDimension(
        door.transform.position,
        { x: door.transform.position.x, y: door.transform.position.y + door.height },
        'elevation',
        viewType,
        floorId,
        {
          label: `Door Height`,
          isAutomatic: true
        }
      );
      dimensions.push(heightDim);
    });

    windows.forEach(window => {
      const heightDim = this.createDimension(
        window.transform.position,
        { x: window.transform.position.x, y: window.transform.position.y + window.height },
        'elevation',
        viewType,
        floorId,
        {
          label: `Window Height`,
          isAutomatic: true
        }
      );
      dimensions.push(heightDim);
    });

    return dimensions;
  }

  /**
   * Create dimension chain
   */
  createDimensionChain(
    dimensionIds: string[],
    direction: 'horizontal' | 'vertical' | 'angled' = 'horizontal',
    baselineOffset: number = 0
  ): DimensionChain2D {
    const id = `chain-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const dimensions = dimensionIds
      .map(dimId => this.dimensions.get(dimId))
      .filter(dim => dim !== undefined) as Dimension2D[];

    const totalValue = dimensions.reduce((sum, dim) => sum + dim.value, 0);

    const chain: DimensionChain2D = {
      id,
      dimensions,
      totalValue,
      direction,
      baselineOffset,
      isLocked: false
    };

    this.chains.set(id, chain);
    return chain;
  }

  /**
   * Update dimension value
   */
  updateDimension(id: string, updates: Partial<Dimension2D>): boolean {
    const dimension = this.dimensions.get(id);
    if (!dimension || dimension.isLocked) return false;

    const updatedDimension = {
      ...dimension,
      ...updates,
      updatedAt: new Date()
    };

    // Recalculate value if points changed
    if (updates.startPoint || updates.endPoint) {
      updatedDimension.value = this.calculateDistance(
        updatedDimension.startPoint.position,
        updatedDimension.endPoint.position
      );
    }

    this.dimensions.set(id, updatedDimension);
    return true;
  }

  /**
   * Delete dimension
   */
  deleteDimension(id: string): boolean {
    return this.dimensions.delete(id);
  }

  /**
   * Get dimensions for view
   */
  getDimensionsForView(viewType: ViewType2D, floorId?: string): Dimension2D[] {
    return Array.from(this.dimensions.values()).filter(dim => {
      const viewMatch = dim.viewType === viewType;
      const floorMatch = !floorId || dim.floorId === floorId;
      return viewMatch && floorMatch && dim.isVisible;
    });
  }

  /**
   * Get all dimensions
   */
  getAllDimensions(): Dimension2D[] {
    return Array.from(this.dimensions.values());
  }

  /**
   * Get dimension chains
   */
  getDimensionChains(): DimensionChain2D[] {
    return Array.from(this.chains.values());
  }

  /**
   * Calculate distance between two points
   */
  private calculateDistance(point1: Point2D, point2: Point2D): number {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Detect rectangular rooms from walls
   */
  private detectRectangularRooms(walls: Wall2D[]): Array<{ bounds: { min: Point2D, max: Point2D } }> {
    // Simplified room detection - find bounding rectangles
    const rooms: Array<{ bounds: { min: Point2D, max: Point2D } }> = [];
    
    if (walls.length >= 4) {
      const allPoints = walls.flatMap(wall => [wall.startPoint, wall.endPoint]);
      const minX = Math.min(...allPoints.map(p => p.x));
      const maxX = Math.max(...allPoints.map(p => p.x));
      const minY = Math.min(...allPoints.map(p => p.y));
      const maxY = Math.max(...allPoints.map(p => p.y));
      
      rooms.push({
        bounds: {
          min: { x: minX, y: minY },
          max: { x: maxX, y: maxY }
        }
      });
    }
    
    return rooms;
  }

  /**
   * Format dimension value for display
   */
  formatDimensionValue(dimension: Dimension2D): string {
    const value = dimension.value;
    const unit = dimension.unit;
    const precision = dimension.precision;
    
    // Convert to display unit if needed
    let displayValue = value;
    let displayUnit = unit;
    
    // Format based on style
    switch (dimension.style) {
      case 'architectural':
        if (unit === 'm' && value < 1) {
          displayValue = value * 100;
          displayUnit = 'cm';
        }
        break;
      case 'engineering':
        // Keep original units
        break;
      case 'metric':
        if (unit === 'm' && value < 0.01) {
          displayValue = value * 1000;
          displayUnit = 'mm';
        }
        break;
      case 'imperial':
        if (unit === 'ft' && value < 1) {
          displayValue = value * 12;
          displayUnit = 'in';
        }
        break;
    }
    
    return `${displayValue.toFixed(precision)}${displayUnit}`;
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<DimensionManagerConfig>): void {
    this.config = { ...this.config, ...updates };
  }

  /**
   * Get current configuration
   */
  getConfig(): DimensionManagerConfig {
    return { ...this.config };
  }
}

export default DimensionManager2D;
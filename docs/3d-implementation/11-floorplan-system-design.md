# 11. Floorplan System Design

> This document outlines the technical architecture for the core floorplan system, including wall representation, room detection, geometry generation, and placement constraints. This is the heart of the house designer's logic.

---

## 1. Data Model & State (Zustand)

The `designStore` will be the single source of truth for the floorplan. We will use a normalized data structure to efficiently manage entities.

```typescript
// Inferred from src/stores/designStore.ts

export interface DesignState {
  elements: {
    walls: { [id: string]: Wall };
    doors: { [id: string]: Door };
    windows: { [id: string]: Window };
    rooms: { [id: string]: Room };
  };
  // ... other state properties
}

export interface Wall {
  id: string;
  start: { x: number; z: number };
  end: { x: number; z: number };
  height: number;
  thickness: number;
  // Connections to other walls at start and end points
  connections: {
    start: string[]; // Wall IDs
    end: string[];   // Wall IDs
  };
}

export interface Door {
  id: string;
  hostWallId: string; // A door must be hosted by a wall
  positionOnWall: number; // Normalized position (0 to 1) along the wall's length
  width: number;
  height: number;
}

export interface Room {
  id: string;
  wallIds: string[]; // The walls that form the boundary of the room
  floorMaterialId?: string;
  ceilingMaterialId?: string;
}
```

## 2. Wall System

The wall system is based on connected line segments in a 2D plane (X-Z).

### Wall Representation

- Each wall is defined by a `start` and `end` point.
- The `connections` property tracks which other walls are connected at each endpoint, forming a graph.

### Wall Drawing & Snapping

1. When a user draws a new wall, the system will check for proximity to the endpoints of existing walls.
2. If the new wall's start or end point is within a snapping threshold, it will snap to the existing point.
3. The `connections` arrays of both the new wall and the existing wall(s) are updated to reflect the new join.

### Wall Splitting (T-Junctions)

1. If a new wall's endpoint snaps to the *body* of an existing wall (not an endpoint), the existing wall will be split into two new walls.
2. The original wall is removed, and two new walls are created that meet at the junction point.
3. The `connections` are updated accordingly to form a "T" junction.

## 3. Room Detection

Rooms are automatically detected by finding closed loops in the wall graph.

### Algorithm: Cycle Detection

1. Start a traversal (e.g., Depth-First Search) from an arbitrary wall endpoint.
2. Follow the `connections` from one wall to the next, always turning in the same direction (e.g., always take the "left-most" turn at a junction) to trace the perimeter.
3. If the traversal returns to the starting point, a closed loop (a room) has been found.
4. The IDs of the walls in the traversal path are collected to define the new `Room` entity.
5. A `Room` object is created and added to the `designStore`.

## 4. 3D Geometry Generation

3D meshes are generated procedurally from the 2D floorplan data.

### Wall Geometry

1. For each `Wall` object, a 3D mesh is generated by extruding its 2D line segment.
2. The extrusion height is determined by `wall.height` and the width by `wall.thickness`.
3. The initial geometry is a simple box (`THREE.BoxGeometry`).

### Openings (Doors & Windows) via CSG

1. Openings for doors and windows are created using **Constructive Solid Geometry (CSG)**.
2. For each door or window hosted on a wall, a "cutter" mesh (a box representing the opening) is created.
3. The cutter mesh is subtracted from the wall's mesh using a CSG library (e.g., `three-csg-ts`).
4. This process is non-destructive. The final wall geometry is generated on-the-fly, and the base wall data remains unchanged.

### Floor & Ceiling Geometry

1. Once a `Room` is detected, its floor and ceiling geometry can be generated.
2. The vertices of the room's perimeter are extracted from the connected `Wall` objects.
3. A 2D shape is created from these vertices.
4. `THREE.ShapeGeometry` or `THREE.ExtrudeGeometry` (with a small height) is used to create the floor and ceiling meshes.

## 5. Constraint & Validation Engine

The system will enforce placement rules to ensure a valid architectural design.

### Host-Based Placement

- **Rule:** Doors and windows can only be placed on a `Wall`. Furniture can only be placed in a `Room`.
- **Implementation:** When a user drags a door, the system will raycast against walls only. The `onDrop` event will associate the door with the `hostWallId`.

### Boundary Constraints

- **Rule:** A door/window cannot be placed such that it extends beyond the ends of its host wall.
- **Implementation:** The `positionOnWall` for a door/window is clamped between `0 + (half_width / wall_length)` and `1 - (half_width / wall_length)`.

### Overlap Detection

- **Rule:** Objects cannot overlap.
- **Implementation:**
  - For walls, this is handled by the snapping and joining logic.
  - For furniture/products, Axis-Aligned Bounding Box (AABB) intersection tests will be performed against other objects within the same room.
  - Invalid placements will be visually indicated to the user (e.g., red outline).
